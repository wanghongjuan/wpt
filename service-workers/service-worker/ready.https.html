<!DOCTYPE html>
<title>Service Worker: navigator.serviceWorker.ready</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
test(function() {
  const promise = navigator.serviceWorker.ready;
  assert_equals(promise, navigator.serviceWorker.ready,
                'repeated access to ready without intervening ' +
                'registrations should return the same Promise object');
  }, 'ready returns the same Promise object');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-installing';
  await service_worker_unregister(t, SCOPE);
  const frame = await with_iframe(SCOPE);

  let registration = await navigator.serviceWorker.register(SCRIPT, {scope: SCOPE});
  await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_not_equals(registration.active, null,
                    'active after ready should not be null');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');

 }, 'ready on an iframe whose parent registers a new service worker');

promise_test(async t => {
  const frame = await with_iframe('resources/blank.html?uncontrolled');
  const registration =
    frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(function() {
    if (frame)
      frame.remove();
  });

  assert_equals(Object.getPrototypeOf(registration),
                frame.contentWindow.Promise.prototype,
                'the Promise should be in the context of the ' +
                'related document');
}, 'ready returns a Promise object in the context of the related document');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-controlled';
  const expected_url = normalizeURL(SCRIPT);

  let registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);
  await wait_for_state(t, registration.installing, 'activated');
  const frame = await with_iframe(SCOPE);
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_equals(registration.active.scriptURL, expected_url,
                'active after ready should not be null');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                registration.active,
                'the controller should be the active worker');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');

}, 'ready on a controlled document');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-potential-controlled';
  const expected_url = normalizeURL(SCRIPT);

  const frame = await with_iframe(SCOPE);
  let registration =
      await navigator.serviceWorker.register(SCRIPT, {scope:SCOPE});

  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null.');
  assert_equals(registration.active.scriptURL, expected_url,
                'active after ready should not be null');
  assert_in_array(registration.active.state,
                  ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                null,
                'uncontrolled document should not have a controller');

  }, 'ready on a potential controlled document');


promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/register-iframe.html';
  const expected_url = normalizeURL(SCRIPT);
  const frame = await with_iframe(SCOPE);
  const registration = await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_not_equals(registration.active, null,
                    'active after ready should not be null');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved with "active worker"');

 }, 'ready on an iframe that installs a new service worker');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const MATCHED_SCOPE = 'resources/blank.html?ready-after-resolve';
  const LONGER_MATCHED_SCOPE =
      'resources/blank.html?ready-after-resolve-longer';

  let registration =
      await service_worker_unregister_and_register(t, SCRIPT, MATCHED_SCOPE);
  await wait_for_state(t, registration.installing, 'activated');
  const frame = await with_iframe(LONGER_MATCHED_SCOPE);
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
  });

  assert_equals(registration.scope, normalizeURL(MATCHED_SCOPE),
                'matched registration should be returned');
  registration = await navigator.serviceWorker.register(
      SCRIPT, {scope: LONGER_MATCHED_SCOPE});
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.scope, normalizeURL(MATCHED_SCOPE),
                'ready should only be resolved once');

  }, 'access ready after it has been resolved');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const MATCHED_SCOPE = 'resources/blank.html?ready-after-match';
  const LONGER_MATCHED_SCOPE = 'resources/blank.html?ready-after-match-longer';

  await service_worker_unregister(t, MATCHED_SCOPE);
  await service_worker_unregister(t, LONGER_MATCHED_SCOPE);
  const frame = await with_iframe(LONGER_MATCHED_SCOPE);
  let registration =
      await navigator.serviceWorker.register(SCRIPT, {scope: MATCHED_SCOPE});
  await wait_for_state(t, registration.installing, 'activated');
  registration =
      await navigator.serviceWorker.register(
                                    SCRIPT, {scope: LONGER_MATCHED_SCOPE});
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  })

  assert_equals(registration.scope, normalizeURL(LONGER_MATCHED_SCOPE),
                'longer matched registration should be returned');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                null, 'controller should be null');

  }, 'ready after a longer matched registration registered');


promise_test(async t => {
    const SCRIPT = 'resources/empty-worker.js';
    const MATCHED_SCOPE = 'resources/blank.html?ready-after-resurrect';

    const registration1 =
        await service_worker_unregister_and_register(t, SCRIPT, MATCHED_SCOPE);

    t.add_cleanup(async()  => {
      if (registration1)
        await registration1.unregister();
      if (frame)
        frame.remove();
      if (registration2)
        await registration1.unregister();
    });

    await wait_for_state(t, registration1.installing, 'activated');

    // Hold the worker alive with a controlled worker
    const frame = await with_iframe(MATCHED_SCOPE);

    // Access the ready promise while the registration is doomed.
    const readyPromise = await frame.contentWindow.navigator.serviceWorker.ready;

    // Resurrect the doomed registration;
    const registration2 =
        await service_worker_unregister_and_register(t, SCRIPT, MATCHED_SCOPE);
    assert_equals(registration1, registration2,
                  'existing registration should be resurrected');

    // We are trying to test if the ready promise ever resolves here.  Use
    // an explicit timeout check here rather than forcing a full infrastructure
    // level timeout.
    let timeoutId;
    const timeoutPromise = new Promise(resolve => {
      timeoutId = setTimeout(_ => {
        timeoutId = null;
        resolve();
      }, 500);
    });

    // This should resolve immediately since there is an alive registration
    // with an active promise for the matching scope.
    await Promise.race([readyPromise, timeoutPromise]);
    assert_not_equals(timeoutId, null,
                      'ready promise should resolve before timeout');
    clearTimeout(timeoutId);
  }, 'access ready on uninstalling registration that is resurrected');
</script>
