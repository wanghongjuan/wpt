<!DOCTYPE html>
<meta charset="utf-8">
<title>Tests for importScripts: import scripts updated flag</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<body>
<script>
// This test registers a worker that calls importScripts at various stages of
// service worker lifetime. The sub-tests trigger subsequent `importScript`
// invocations via the `message` event.

let register;

function post_and_wait_for_reply(worker, message) {
  return new Promise(resolve => {
      navigator.serviceWorker.onmessage = e => { resolve(e.data); };
      worker.postMessage(message);
    });
}

promise_test(async t => {
    const SCOPE = 'resources/import-scripts-updated-flag';
    const SCRIPT = 'resources/import-scripts-updated-flag-worker.js';
    const registration =
        await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

    add_completion_callback(async() => {
      if (registration)
        await registration.unregister();
    });

    await wait_for_state(t, registration.installing, 'activated');
    promise_test(async() =>{
      await registration.unregister();
    });
    register = registration.active;
}, 'initialize global state');

promise_test(async t =>{
  const result = await post_and_wait_for_reply(register, 'root-and-message');
  assert_equals(result.error, null);
  assert_equals(result.value, 'root-and-message');
}, 'import script previously imported at worker evaluation time');

promise_test(async t => {
  const result = await post_and_wait_for_reply(register, 'install-and-message');
  assert_equals(result.error, null);
  assert_equals(result.value, 'install-and-message');
}, 'import script previously imported at worker install time');

promise_test(async t => {
  const result = await post_and_wait_for_reply(register, 'message');
  assert_equals(result.error, 'NetworkError');
  assert_equals(result.value, null);
}, 'import script not previously imported');
</script>
</body>
