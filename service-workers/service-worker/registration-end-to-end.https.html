<!DOCTYPE html>
<title>Service Worker: registration end-to-end</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
promise_test(async t => {
  const SCOPE = 'resources/in-scope/';
  const SCRIPT = 'resources/end-to-end-worker.js';
  let serviceWorkerStates = [];
  const currentChangeCount = 0;

  assert_true(navigator.serviceWorker instanceof ServiceWorkerContainer);
  assert_equals(typeof navigator.serviceWorker.register, 'function');
  assert_equals(typeof navigator.serviceWorker.getRegistration, 'function');

  navigator.serviceWorker.oncurrentchange = function() {
      ++currentChangeCount;
  };

  const registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
  })

  function sendMessagePort(worker, from) {
    const messageChannel = new MessageChannel();
    worker.postMessage({from:from, port:messageChannel.port2}, [messageChannel.port2]);
    return messageChannel.port1;
  }

  async function onRegister(registration) {
    const sw = registration.installing;
    serviceWorkerStates.push(sw.state);
    lastServiceWorkerState = sw.state;

    const sawMessage =  new Promise(resolve => {
        sendMessagePort(sw, 'registering doc').onmessage = function (e) {
            receivedMessageFromPort = e.data;
            resolve();
        };
    });

    const sawActive = new Promise(resolve => {
        sw.onstatechange = function() {
            serviceWorkerStates.push(sw.state);

            switch (sw.state) {
            case 'installed':
                assert_equals(lastServiceWorkerState, "installing");
                break;
            case 'activating':
                assert_equals(lastServiceWorkerState, "installed");
                break;
            case 'activated':
                assert_equals(lastServiceWorkerState, "activating");
                break;
            default:
                // We won't see "redundant" because onstatechange is
                // overwritten before calling unregister.
                assert_unreached("Unexpected state: " + sw.state);
            }

            lastServiceWorkerState = sw.state;
            if (sw.state === 'activated')
                resolve();
        }
    });

    await Promise.all([sawMessage, sawActive]);
    assert_array_equals(serviceWorkerStates,
                        ['installing', "installed", "activating", "activated"],
                        "Service worker should pass through all states");

    assert_equals(currentChangeCount, 0,
                  "Should not see current changes since document is out of scope");

    assert_equals(receivedMessageFromPort, "Ack for: registering doc");

    await new Promise(resolve => {
        sw.onstatechange = function() {
            assert_equals(sw.state, "redundant");
            resolve();
        }
    });
  }
});

</script>
