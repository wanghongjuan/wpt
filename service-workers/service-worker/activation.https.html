<!DOCTYPE html>
<meta charset="utf-8">
<title>service worker: activation</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<body>
<script>
// Returns {registration, iframe}, where |registration| has an active and
// waiting worker. The active worker controls |iframe| and has an inflight
// message event that can be finished by calling
// |registration.active.postMessage('go')|.
async function setup_activation_test(t, scope, worker_url) {
  let registration = await navigator.serviceWorker.getRegistration(scope);
  const iframe = await with_iframe(scope);
  registration = await navigator.serviceWorker.register(worker_url, 
                                                        { scope: scope });
  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
    if (iframe)
      iframe.remove();
  });

  await wait_for_state(t, registration.installing, 'activated');
  // Check that the frame was claimed.
  assert_not_equals(
      iframe.contentWindow.navigator.serviceWorker.controller, null);
  // Create an in-flight request.
  registration.active.postMessage('wait');
  // Now there is both a controllee and an in-flight request.
  // Initiate an update.
  await registration.update();
  // Wait for a waiting worker.
  await wait_for_state(t, registration.installing, 'installed');
  await wait_for_activation_on_dummy_scope(t, self);
  assert_not_equals(registration.waiting, null);
  assert_not_equals(registration.active, null);
  return Promise.resolve({registration: registration, iframe: iframe});
}
promise_test(async t => {
  const SCOPE = 'resources/no-controllee';
  const WORKER_URL = 'resources/mint-new-worker.py';
  const result = await setup_activation_test(t, SCOPE, WORKER_URL);
  const registration = result.registration;
  const iframe = result.iframe;
  // Finish the in-flight request.
  registration.active.postMessage('go');
  await wait_for_activation_on_dummy_scope(t, self);
  // The new worker is still waiting. Remove the frame and it should activate.
  const new_worker = registration.waiting;
  iframe.remove();
  assert_equals(new_worker.state, 'installed');
  await wait_for_state(t, new_worker, 'activating');
  assert_equals(new_worker, registration.active);
}, 'loss of controllees triggers activation');

promise_test(async t => {
  const SCOPE = 'resources/no-request';
  const WORKER_URL = 'resources/mint-new-worker.py';
  const result = await setup_activation_test(t, SCOPE, WORKER_URL);
  const registration = result.registration;
  const iframe = result.iframe;
  // Remove the iframe.
  iframe.remove();
  await new Promise(resolve => setTimeout(resolve, 0));
  const new_worker = registration.waiting;
  registration.active.postMessage('go');
  await wait_for_state(t, new_worker, 'activating');
  assert_equals(registration.active, new_worker);
}, 'finishing a request triggers activation');

promise_test(async t => {
  const SCOPE = 'resources/skip-waiting';
  const WORKER_URL = 'resources/mint-new-worker.py?skip-waiting';
  const result = await setup_activation_test(t, SCOPE, WORKER_URL);
  const registration = result.registration;
  // Finish the request. The iframe does not need to be removed because
  // skipWaiting() was called.
  const new_worker = registration.waiting;
  registration.active.postMessage('go');
  await wait_for_state(t, new_worker, 'activating');
  assert_equals(registration.active, new_worker);
}, 'skipWaiting bypasses no controllee requirement');

// This test is not really about activation, but otherwise is very
// similar to the other tests here.
promise_test(async t => {
  const SCOPE = 'resources/unregister';
  const WORKER_URL = 'resources/mint-new-worker.py';
  const result = await setup_activation_test(t, SCOPE, WORKER_URL);
  const registration = result.registration;
  const iframe = result.iframe;
  // Remove the iframe.
  iframe.remove();
  await registration.unregister();
  // The unregister operation should wait for the active worker to
  // finish processing its events before clearing the registration.
  const new_worker = registration.waiting;
  registration.active.postMessage('go');
  await wait_for_state(t, new_worker, 'redundant');
  assert_equals(registration.installing, null);
  assert_equals(registration.waiting, null);
  assert_equals(registration.active, null);
}, 'finishing a request triggers unregister');
</script>
</body>
