<!DOCTYPE html>
<title>Service Worker: postMessage</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
const SCOPE = 'resources/blank.html';

promise_test(async t => {
  const SCRIPT = 'resources/postmessage-worker.js';
  const registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

  t.add_cleanup(async() => {
    if (registration)
      await registration.unregister();
  });

  const worker = registration.installing;
  const messageChannel = new MessageChannel();
  const port = messageChannel.port1;

  let event = await new Promise(resolve => {
                port.onmessage = resolve;
                worker.postMessage({port: messageChannel.port2},
                                   [messageChannel.port2]);
                worker.postMessage({value: 1});
                worker.postMessage({value: 2});
                worker.postMessage({done: true});
              });
  assert_equals(event.data, 'Acking value: 1');

  event = await new Promise(resolve => { port.onmessage = resolve; });
  assert_equals(event.data, 'Acking value: 2');

  event = await new Promise(resolve => { port.onmessage = resolve; });
  assert_equals(event.data, 'quit');

  await registration.unregister();
  await wait_for_state(t, worker, 'redundant');
  assert_equals(worker.state, 'redundant');
  assert_throws(
    {name:'InvalidStateError'},
    function() { worker.postMessage(''); },
    'Calling postMessage on a redundant ServiceWorker should ' +
    'throw InvalidStateError.');

}, 'postMessage to a ServiceWorker (and back via MessagePort)');

promise_test(async t => {
  const SCRIPT = 'resources/postmessage-transferables-worker.js';
  const MESSAGE = 'Hello, world!';

  const worker = navigator.serviceWorker;
  const text_encoder = new TextEncoder;
  const text_decoder = new TextDecoder;
  const registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

  t.add_cleanup(async() => {
    if (registration)
      await registration.unregister();
  });

  const code = text_encoder.encode(MESSAGE);
  assert_equals(code.byteLength, MESSAGE.length);
  registration.installing.postMessage(code, [code.buffer]);
  assert_equals(text_decoder.decode(code), '');
  assert_equals(code.byteLength, 0);

  // Verify the integrity of the transferred array buffer.
  let event = await new Promise(resolve => { worker.onmessage = resolve; });
  assert_equals(event.data.content, MESSAGE);
  assert_equals(event.data.byteLength, MESSAGE.length);
  
  // Verify the integrity of the array buffer sent back from
  // ServiceWorker via Client.postMessage.
  event = await new Promise(resolve => { worker.onmessage = resolve; });
  assert_equals(text_decoder.decode(event.data), MESSAGE);
  assert_equals(event.data.byteLength, MESSAGE.length);

  // Verify that the array buffer on ServiceWorker is neutered.
  event = await new Promise(resolve => { worker.onmessage = resolve; });
  assert_equals(event.data.content, '');
  assert_equals(event.data.byteLength, 0)

  }, 'postMessage a transferable ArrayBuffer between ServiceWorker and Client');

promise_test(async t => {
  const SCRIPT = 'resources/postmessage-transferables-worker.js';
  const MESSAGE = 'Hello, world!';
  const text_encoder = new TextEncoder;
  const text_decoder = new TextDecoder;

  const registration = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

  t.add_cleanup(async() => {
    if (registration)
      await registration.unregister();
  });

  const channel = new MessageChannel;
  const port = channel.port1;
  registration.installing.postMessage(undefined, [channel.port2]);

  const code = text_encoder.encode(MESSAGE);
  assert_equals(code.byteLength, MESSAGE.length);
  port.postMessage(code, [code.buffer]);
  assert_equals(text_decoder.decode(code), '');
  assert_equals(code.byteLength, 0);

  // Verify the integrity of the transferred array buffer.
  let event = await new Promise(resolve => { port.onmessage = resolve; });
  assert_equals(event.data.content, MESSAGE);
  assert_equals(event.data.byteLength, MESSAGE.length);

  // Verify the integrity of the array buffer sent back from
  // ServiceWorker via Client.postMessage.
  event = await new Promise(resolve => { port.onmessage = resolve; });
  assert_equals(text_decoder.decode(event.data), MESSAGE);
  assert_equals(event.data.byteLength, MESSAGE.length);

  // Verify that the array buffer on ServiceWorker is neutered.
  event = await new Promise(resolve => { port.onmessage = resolve; });
  assert_equals(event.data.content, '');
  assert_equals(event.data.byteLength, 0);

}, 'postMessage a transferable ArrayBuffer between ServiceWorker and Client' +
   ' over MessagePort');
</script>
